# 리액트와 최적화 테크닉 살펴보기

## 1. 리액트의 컴포넌트 트리 생성 & 리액트가 시스템 뒷편에서 동작하는 방식

### 1) 컴포넌트 함수들은 어떻게 실행되는가?

- 컴포넌트를 화면에 렌더링한다는 것은 리액트가 컴포넌트 함수들을 실행한다는 뜻
- 컴포넌트 함수의 코드들은 전부 순차적으로 실행됨
- JSX 코드가 결과적으로 해당 컴포넌트를 통해 반환됨
    - 모든 컴포넌트 함수들은 렌더링될 수 있는 것들만 반환해야 함

        예) JSX 코드나 Portal 등

    - JSX 코드는 결과적으로 자바스크립트 코드로 변환되어야 하고, 화면에 렌더링 될 수 있는 실제 요소로 변환되어야 함
- JSX 코드에는 커스텀 컴포넌트와 HTML 요소들이 있음
    - HTML 요소들은 소문자로 시작
    - 커스텀 컴포넌트는 HTML 요소와 분리하기 위해 대문자로 시작
- JSX 코드를 반환할 때는 리액트가 해당 컴포넌트를 처음부터 끝까지 실행
    - 커스텀 컴포넌트를 만나면 해당 커스텀 컴포넌트 함수들과 그 안의 코드들을 전부 실행시킴

### 2) 리액트는 어떻게 DOM을 업데이트 하는가?

```jsx
// 우리 프로젝트의 컴포넌트 트리
<App /> rendered
- <Header /> rendered
- <Counter /> rendered
- - Calculating if is prime number
- - <IconButton /> rendered
- - - <MinusIcon /> rendered
- - <CounterOutput /> rendered
- - <IconButton /> rendered
- - - <PlusIcon /> rendered
```

- 리액트는 DOM 업데이트를 효율적으로 처리하기 위해 **Virtual DOM**이라는 개념을 사용
    1. **Virtual DOM 생성**: 리액트 컴포넌트가 렌더링될 때, 실제 DOM 대신 가상 DOM(메모리에 있는 가벼운 객체)을 생성
    2. **변경 사항 감지**: 상태(state)나 props가 변경되면 리액트는 새로운 Virtual DOM을 생성하고 이전 Virtual DOM과 비교(diffing)하여 변경된 부분을 찾음
    3. **최소한의 업데이트**: 변경된 부분만 실제 DOM에 반영하여, 불필요한 DOM 조작을 최소화

## 2. 리액트 DevTools Profiler로 컴포넌트 함수 실행 및 분석하기

- 리액트 DevTools은 간단하게 확장 기능이라고 볼 수 있음
- 개발자 도구를 열어 Profiler 탭으로 갈 수 있음

### 1) Profiler 탭

- 어떤 컴포넌트들이 업데이트 중이고, 렌더링 중인지를 이해하는 데 사용
- 컴포넌트들이 어떻게 실행되는지도 이해할 수 있고, 왜 실행되었는지도 알 수 있음
- 사용 방법
    - 좌측의 동그라미 버튼으로 프로파일링을 시작할 수 있음

        ![스크린샷 2024-08-25 15.55.27.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c07a89d2-eb34-4064-ae88-37dd3da5bb9e/9e037db2-cbac-40a5-b4bc-d003ed852b03/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-25_15.55.27.png)

    - 그 후 페이지와 상호작용 할 수 있음

        ![스크린샷 2024-08-25 15.56.35.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c07a89d2-eb34-4064-ae88-37dd3da5bb9e/57876e73-4d50-464d-82e1-1c6dff60292d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-25_15.56.35.png)

        - 해당 상호작용의 결과를 그래픽 데이터로 확인할 수 있음
        - 어떤 컴포넌트 함수들이 어떠한 이유로 실행되었는지를 보여줌
- 이 시각화 방식은 원하는 대로 바꿀 수 있음
    - 불꽃(flame) 그래프 모드

        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c07a89d2-eb34-4064-ae88-37dd3da5bb9e/dcf9d2c5-07e9-4137-ac39-f26731a5a360/image.png)

        - 마지막에 결과를 확인할 때, 컴포넌트 함수들이 실행된 순서가 포함되어 있음
        - 컴포넌트 함수들과의 관계도 확인 가능
    - 순위(Ranked) 차트 모드

        ![스크린샷 2024-08-25 16.01.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c07a89d2-eb34-4064-ae88-37dd3da5bb9e/a3e2f0e0-ad90-42c1-8ec8-90859a76791b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-25_16.01.54.png)

        - 다시 렌더링된 컴포넌트들을 확인 가능
        - 최종적으로 재렌더링 사이클에 필요한 컴포넌트들을 확인 가능

            → 하단 컴포넌트들은 중첩 컴포넌트들


    ⇒ 어떤 컴포넌트들이 재실행되었고, 서로 어떻게 연관되어 있는지 확인 가능

- 설정 > Profiler 에 들어가서 왜 각 컴포넌트가 렌더링되었는지를 기록할 수 있는 체크박스를 클릭한 후 프로파일링을 시작하면, 컴포넌트에 마우스를 올리면 해당 컴포넌트가 왜 바뀌었는지 확인 가능

    ![스크린샷 2024-08-25 16.06.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c07a89d2-eb34-4064-ae88-37dd3da5bb9e/f0b19826-8a7e-4dcd-97e1-94e787fe3c97/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-25_16.06.57.png)


## 3. `memo()`로 컴포넌트 함수 실행 방지

- 리액트는 내장 함수를 지원하기 때문에, 컴포넌트들을 감쌀 수 있고 불필요한 컴포넌트 함수 실행을 방지함

    → 이 함수는 `memo` 함수


### 1) `memo` 함수

- 컴포넌트 함수가 정상적으로 다시 실행될 때, 이전 속성 값과 새로 받을 속성 값을 살펴봄
- 속성 값들이 완전히 동일하다면, 즉 배열이나 객체가 메모리 안에 있는 배열이나 객체와 동일하다면, 해당 컴포넌트 함수 실행을 `memo` 가 실행을 방지하여 해당 컴포넌트 함수가 딱 한 번만 실행됨
- 내부 상태 값이 바뀌는 것과 같은 변화는 `memo` 에 아무런 영향을 주지 않음
    - `memo` 는 오직 부모 컴포넌트에 의해 컴포넌트 함수가 실행되었을 때만 실행 방지
    - 외부적 변화도 마찬가지로 해당 컴포넌트 안의 속성 값이 바뀌어야만 해당 컴포넌트 함수가 실행됨

### 2) `memo` 로 모든 컴포넌트 함수를 감싸서 사용해도 될까?

- 모든 컴포넌트 함수를 감싸서는 안됨
    - 모든 컴포넌트 함수를 `memo` 로 감싼다면, 리액트는 컴포넌트 함수를 실행하기 전 항상 속성들을 확인해야 함
    - 속성 값을 확인하는 것은 그만큼 성능에 부담을 주게 됨
    - 특히, 함수를 감쌀 때 문제가 됨
        - 항상 속성을 바꿔야 하기 때문
    - 그렇기 때문에 항상 모든 컴포넌트 함수가 실행되어야 한다는 결과를 도출해냄
        - 왜냐하면 `memo` 를 사용하지 않았을 때와 동일한 결과를 얻기 위해 이 확인 과정을 수행함으로써 성능에 효율적이기 때문
- 최대한 상위 트리에 속한 컴포넌트를 감싸는 것은 가능

    예) `Counter` 컴포넌트

    - 왜냐하면 해당 컴포넌트가 재실행되는 것이 방지된다면, 모든 중첩 컴포넌트들 또한 재실행되지 않을 것이기 때문

## 4. 컴포넌트 함수 실행 방지를 위한 구조

- `memo` 는 신경써서 사용한다면 유용하지만, 꼭 이것만이 불필요한 렌더링을 방지할 수 있는 방법은 아님
- 좀 더 강력한 방법은 앱 내에 현명한 컴포넌트를 구성하는 것

### 1) 예시

```jsx
// App.jsx
import { useState } from 'react';

import Counter from './components/Counter/Counter.jsx';
import Header from './components/Header.jsx';
import { log } from './log.js';
import ConfigureCounter from './components/Counter/ConfigureCounter.jsx';

function App() {
  log('<App /> rendered');

  const [chosenCount, setChosenCount] = useState(0);

  function handleSetCount(newCount) {
    setChosenCount(newCount);
  }

  return (
    <>
      <Header />
      <main>
        <ConfigureCounter onSet={handleSetCount} />
        <Counter initialCount={chosenCount} />
      </main>
    </>
  );
}

export default App;

// ConfigureCount.jsx
import { useState } from 'react';

import {log} from '../../log.js'

export default function ConfigureCounter({onSet}) {
  log('<ConfigureCounter />');

  const [enteredNumber, setEnteredNumber] = useState(0);

  function handleChange(event) {
    setEnteredNumber(+event.target.value);
  }

  function handleSetClick() {
    onSet(enteredNumber)
    setEnteredNumber(0);
  }
  return (
    <section id='configure-counter'>
      <h2>Set Counter</h2>
      <input
        type='number'
        onChange={handleChange}
        value={enteredNumber}
      />
      <button onClick={handleSetClick}>Set</button>
    </section>
  );
}
```

- 입력 필드에 키보드 이벤트가 생길 때마다 모든 컴포넌트가 렌더링되는 것을 방지하기 위해 `ConfigureCount` 컴포넌트로 상태를 별도 분리
    - 매 입력마다 모든 컴포넌트들이 재실행되지 않을 것
        - 상태가 바뀌어도 자식 컴포넌트의 재실행은 부모 컴포넌트의 실행을 야기하지 않기 때문
- 개발자 도구를 열어 콘솔을 확인하면, Set Counter의 숫자를 바꿨을 때 모든 컴포넌트가 렌더링되는 것이 아니라 `ConfigureCount` 컴포넌트만 실행되는 것을 확인할 수 있음
- 이제 `Counter` 컴포넌트에서 memo는 필요하지 않기 때문에 제거해주어야 함

## 5. `useCallback()` 훅 이해하기

- `useCallback` 은 함수의 재생성을 방지하기 위해 사용
- 함수를 `useEffect` 의 의존성으로 갖고 있을 때도 필요
- `memo` 를 사용할 때, 불필요한 재실행을 방지하기 위해서도 필요

## 6. `useMemo()` 훅 이해하기

- `memo` 를 사용하여 컴포넌트 함수 실행을 방지하고 싶다면, 입력값이 바뀌지 않는 이상 컴포넌트 함수 내에 불러온 일반 함수들의 실행도 방지해야 함
- `useMemo` 훅은 `memo` 와 혼동해서는 안됨
    - `memo` 는 컴포넌트 함수를 감싸는 데 사용

### 1) `useMemo`

- 컴포넌트 함수 안에 있는 일반 함수들을 감싸고, 일반 함수의 실행을 방지
- 이 훅은 복잡한 계산이 있을 때만 사용해야 함
- 예)

    ```jsx
    import { useState } from 'react'
    ;
    const initialCountIsPrime = useMemo(() => isPrime(initialCount), [initialCount]);
    ```

    - 리액트로 하여금 익명의 화살표 함수를 실행시키고, `useMemo` 로 전달
        - 그런 다음, 익명 함수에 반환된 이 실행의 결과인 일반 함수를 불러온 결과를 최종적으로 저장
    - 익명의 화살표 함수는 의존성들이 하나라도 바뀔 경우에만 재실행됨
        - 의존성이 빈 배열일 경우, 바뀔 수 있는 의존성이 없기 때문에 절대 재실행되지 않음
- `useMemo`를 사용하여 함수들을 전부 감싸는 등 남용해서는 안됨
    - `memo` 와 마찬가지로 추가적인 의존성 값 비교를 수행해야 하기 때문
    - 매 컴포넌트 함수가 실행될 때마다 재실행되어야 하는 함수가 있다면, 추가적으로 의존성 값을 확인하는 과정은 필요하지 않음

        → 그저 성능을 낭비할 뿐

- `useMemo` 의 장점
    - 지나친 재실행을 방지할 수 있음
    - 어떤 코드를 실행할지에 따라 소요 시간이 길어질 수 있는 경우 합리적

## 7. 리액트의 가상 DOM 사용 - 직접 살펴보기

### 1) 컴포넌트 함수가 렌더링되는 과정

- 컴포넌트 함수가 실행될 때 실제로 무슨 일이 일어나고, JSX 코드가 어떻게 화면에 나타나는지 알아보자
    - 컴포넌트 함수가 실행되고 JSX 코드가 반환되면, 컴포넌트 트리가 생성됨
    - 전체 컴포넌트 트리가 마지막에 해결된다면, 최종적으로 JSX 코드의 HTML 요소들로 끝나게 됨
    - 그리고 이 HTML 코드가 DOM에 삽입됨

    ⇒ HTML 요소가 컴포넌트들로부터 반환되고, DOM으로 삽입된다는 개념

    ⇒ 페이지에 처음 방문하거나, 페이지를 새로고침 했을 때 생기는 일


### 2) 가상 DOM

- 컴포넌트 함수가 재실행되었다고 해서 컴포넌트 함수가 생성한 모든 JSX 코드가 DOM으로 재삽입 되지 않음
- 리액트는 가상 DOM이라는 것을 사용해서 실제 DOM의 어떤 부분들이 업데이트 되어야 하는지 찾음
- 가상 DOM을 사용하는 이유
    - 가상 DOM은 메모리 안에서만 존재하기 때문에 실제 DOM을 사용하는 것보다 빠름

### 3) 가상 DOM이 동작하는 방식

- 페이지를 새로 방문하거나 새로고침 하면 전체 리액트 앱이 시작되어 처음 렌더링 됨
- 리액트는 컴포넌트 트리를 만듦
- 마지막에는 렌더링 되어야 할 실제 HTML 코드를 컴포넌트 트리로부터 전달받음
- 그리고 가상 DOM snapshot을 생성

⇒ 아직 실제 DOM에는 다다르지 않았고, 실제 DOM이 어떻게 보여야 하는지 가상으로 나타냄

- 리액트는 생성됐었던 마지막 가상 DOM 스냅샷과 현재 가상 DOM 스냅샷을 비교
    - 앱이 방금 시작되었다면, 이전의 스냅샷은 없을 것
- 리액트는 바뀐 것을 전부 확인하고, 실제 DOM에 가서 변동 사항들을 적용
    - 가상 DOM 전체가 실제 DOM으로 삽입된다는 뜻
- 가상 DOM에서 바뀐 부분이 있다면, 다시 컴포넌트 트리를 만들고 트리에서 바뀐 부분과 실행된 컴포넌트 함수들만 빠르게 찾아내어 리액트는 업데이트 된 HTML 코드를 전달
    - 그리고 이것을 이전 코드와 비교

    ⇒ 아직 실제 DOM과 비교하지 않았고, 현재와 이전의 가상 DOM 스냅샷을 비교한 것

    - 빠르게 바뀐 부분을 찾아내어, 리액트는 오직 변동사항들만 실제 DOM에 적용

## 8. State(상태)를 관리할 때 Key(키)의 역할

### 1) State(상태)

- 컴포넌트에 등록된 상태
- 해당 컴포넌트의 범위 내에 속해있음
- 컴포넌트를 재사용할 때마다 재생성됨
- 같은 컴포넌트를 사용해 인스턴스를 만들면, 모든 인스턴스는 각자의 상태를 가짐
    - 같은 이름의 상태를 가졌다고 해서 공유되는 것이 아니라 독립적인 것
    - 이것이 컴포넌트의 재사용을 가능케 함
- 상태는 리액트가 위치에 따라 추적
    - 특정 컴포넌트 인스턴스에 속한 상태가 어떻게 컴포넌트 인스턴스를 건너뛰고 이동할 수 있는걸까?

        → 위치로 추적하기 때문

    - 컴포넌트 인스턴스 즉, 컴포넌트의 유형(type)이 중요
        - 컴포넌트 인스턴스의 위치와도 관련이 있음
    - 상태는 해당 컴포넌트의 type에만 속한 것이 아니라 컴포넌트가 사용되는 위치에도 속해 있는 것
    - 상태는 위치와 컴포넌트 유형에 속해있기 때문에 `CounterHistory` 에서 내가 어떤 값을 선택한 후 새로운 값을 추가했을 때, 위치가 아래로 밀리면서 다른 값이 선택되게 됨
        - 이것을 피할 수 있는 매커니즘인 Key(키)를 제공

### 2) Key(키)

- 키는 리액트에서 상태를 구체적인 컴포넌트 인스턴스에 매핑할 때 고려되는 요소
- 데이터의 순서가 바뀌어도 인덱스는 항상 유지되는 값이기 때문에, 키 값으로 적절하지 않음
- 특정 값과 연결된 키 값을 사용해야 함
- Key가 중요한 이유
    - 비슷한 컴포넌트를 포함한 동적인 목록이 있을 때, 리액트가 컴포넌트를 확실히 식별해내도록 하기 때문

## 9. Key(키)가 중요한 이유 - 부가 설명

- 키 값을 사용하면 이전의 가상 DOM 스냅샷의 키를 알기 때문에, 이전 DOM 요소들을 재사용할 수 있고 재생성하지 않아도 됨
    - 그냥 새로운 요소를 앞에 삽입하기만 하면 됨
- 키를 사용하는 것은 상태 관리에 도움될 뿐만 아니라 리액트가 목록을 더 완벽하게 개선할 수 있도록 도와줌

## 10. Key(키)를 사용한 컴포넌트 초기화

- setCounter에서 원하는 값을 세팅하여 counter-output에도 적용되게 하기
    - 방법 1) `useEffect` 사용

        ```jsx
        useEffect(() => {
          setCounterChanges([{value: initialCount, id: Math.random() * 1000}]);
        }, [initialCount]);
        ```

        - `useEffect` 의 사용은 제한하기를 권장
        - 대부분의 경우 최적의 방법으로 쓰이지 않고, 추가적인 컴포넌트 실행을 요구하기 때문
        - `useEffect` 함수 안의 내용이 컴포넌트 함수 실행 이후에 실행되는데, 여기서 상태 값이 바뀌면 또 다른 컴포넌트 함수 실행을 야기함
        - 하나면 될 것을 두 개의 컴포넌트 함수가 실행되어야 하는 것
    - 방법 2) key 사용

        ```jsx
        <main>
          <ConfigureCounter onSet={handleSetCount} />
          <Counter key={chosenCount} initialCount={chosenCount} />
          <Counter  initialCount={0} />
        </main>
        ```

        - 같은 키 값을 컴포넌트에 중복해서 사용할 수 없다는 것을 주의
        - 키 값이 바뀔 때마다 리액트는 이전 컴포넌트 인스턴스는 삭제하고 재생성함
        - 이 패턴은 키 값을 적용하고자 하는 컴포넌트의 외부 컴포넌트에서 변경될 수 있는 상태가 있는 경우에 사용해야 함

            → 부모 컴포넌트에 상태 값이 있어야 하고, 자식 컴포넌트에 이 값을 키 값으로 적용할 수 있어야 함

        - 이 방식을 사용하면 추가적인 컴포넌트 실행을 피할 수 있음

## 11. State(상태) 스케줄링 & 배칭

### 1) State(상태) 업데이트 함수의 실행 스케줄이 리액트에서 어떻게 조정되고 실행되는가?

- State(상태) 업데이트 함수를 불러오면, 상태 업데이트 함수는 리액트로부터 스케줄이 조정됨
    - 바로 실행되지 않음
    - 상태 업데이트 함수 바로 다음 줄에 `console.log` 로 상태를 보면, 새로운 상태는 보이지 않고 이전 상태만 보임
    - 컴포넌트 함수의 이전 실행에 속한 상태 값도 바뀌지 않음
- 상태 업데이트 함수는 새로운 컴포넌트 함수 실행을 야기하고, 다음 실행을 위한 새로운 상태가 준비됨
- 상태 업데이트에는 실행 스케줄이 따로 있기 때문에, 이전 상태 값에 의존하는 상태 업데이트를 실행하기 위해서는 화살표 함수를 사용하는 것이 좋음

    ```jsx
    setState((prevState) => {
    	... prevState,
    	newState
    });
    ```

    - 상태 업데이트 함수에 인자로 함수를 전달하면, 이 함수는 이전 상태 스냅샷을 받아 새로운 상태 스냅샷을 반환
    - 이런 형태를 사용할 때는 리액트가 가장 최신의 상태 스냅샷을 보장
    - 만약 여러 상태 업데이트가 동시에 생긴다면 스케줄링된 순서대로 실행될 것

### 2) 상태 스케줄 조정에서 중요한 것

- 하나의 일반 함수 안에 상태 업데이트 함수가 여러 개 있고 동시에 실행되어야 한다면, 여러 컴포넌트가 동시에 실행되지 않음

    ```jsx
    function handleSetCount(newCount) {
      setChosenCount(newCount);
      setChosenCount((prevChosenCount) => prevChosenCount + 1);
      console.log(chosenCount); // 이렇게는 사용하면 원하는 대로 작동하지 않음
    }
    ```

    - 이유는 비효율적이기 떄문
    - 컴포넌트가 동시에 실행된다는 것은 리액트가 신경쓰지 않을 때 생길 수 있는 일
    - 상태 업데이트 함수를 사용하면 컴포넌트 함수는 재실행되는데, 위와 같은 상황에서는 상태 업데이트 함수가 두 개가 있으므로 컴포넌트 함수의 재실행이 두번 일어난다고 예상할 수 있음

        → 그러나 우리 프로젝트에서 `App` 컴포넌트의 실행은 한 번만 일어남

        → 이것이 리액트가 상태 배칭(State Batching)을 한 것


### 3) 상태 배칭(State Batching)

- 상태 업데이트 함수가 여러 개 있을 때, 다같이 배칭되어서 한 번의 컴포넌트 함수 실행을 유도

## 12. MillionJS로 리액트 최적화하기

### 1) `Million.js` 패키지란?

[Million](https://million.dev/)

- 리액트 앱의 성능을 최적화 하는 데 사용하는 `Million.js` 패키지
- 이 패키지는 리액트를 70% 더 빠르게 할 수 있음
- 무료로 제공되는 패키지
- 공식 문서에서 configuration option을 보면 성능을 최대로 끌어올리기 위한 모든 것이 있음
    - automatic 모드로 시작해볼 수 있음
    - 이 모드는 프로젝트에 추가해 간단하게 사용 가능
        - 프로젝트에 설치하기만 하면 됨

            ```jsx
            npx million@latest
            ```

        - 우리 프로젝트는 vite 기반의 프로젝트이기 때문에, `vite.config.js` 에 들어가 수정

### 2) `Million.js` 패키지를 사용하여 개선할 수 있는 것

- 복잡한 앱에서 출력하고 업데이트 되는 상호적 데이터가 많을 경우, `Million.js` 가 앱의 속도를 올려줄 수 있을지도 모름
- `Million.js` 는 리액트의 가상 DOM 매커니즘을 대체하여 더 효율적인 매커니즘으로 더 빠르게 DOM 업데이트를 수행하기 때문에, 리액트의 기존 알고리즘보다 더 효율적이로 빠름
